一、锁
java提供的锁机制有两种，关键字和concurrent包下的lock锁
1.关键字volatile：synchronized是Java中的关键字，用于实现内置锁（Intrinsic Lock）机制。它可以用于方法或代码块上，用来标识需要同步访问的代码区域。当线程进入synchronized保护的代码区域时，会尝试获取对象的内置锁，如果锁没有被其他线程占用，则获取成功，执行代码区域，执行完毕后释放锁。如果锁已被其他线程占用，则线程进入阻塞状态，等待锁的释放。
synchronized关键字最主要有以下3种应用方式，下面分别介绍：
- 修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁
- 修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁
- 修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。
  https://blog.csdn.net/javazejian/article/details/72828483
synchronized底层语义原理：
对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充
Java 虚拟机中的同步(Synchronization)基于进入和退出管程(Monitor)对象实现， 无论是显式同步(有明确的 monitorenter 和 monitorexit 指令,即同步代码块)还是隐式同步都是如此。在 Java 语言中，同步用的最多的地方可能是被 synchronized 修饰的同步方法。
同步方法 并不是由 monitorenter 和 monitorexit 指令来实现同步的，而是由方法调用指令读取运行时常量池中方法的 ACC_SYNCHRONIZED 标志来隐式实现的，关于这点，稍后详细分析。下面先来了解一个概念Java对象头，这对深入理解synchronized实现原理非常关键。

实例变量：存放类的属性数据信息，包括父类的属性信息，如果是数组的实例部分还包括数组的长度，这部分内存按4字节对齐。
填充数据：由于虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐，这点了解即可。
而对于顶部，则是Java头对象，它实现synchronized的锁对象的基础，这点我们重点分析它，一般而言，synchronized使用的锁对象是存储在Java对象头里的，jvm中采用2个字来存储对象头(如果对象是数组则会分配3个字，多出来的1个字记录的是数组长度)，其主要结构是由Mark Word 和 Class Metadata Address 组成，其结构说明如下表

虚拟机位数	头对象结构	说明
32/64bit	Mark Word	存储对象的hashCode、锁信息或分代年龄或GC标志等信息
32/64bit	Class Metadata Address	类型指针指向对象的类元数据，JVM通过这个指针确定该对象是哪个类的实例。

其中Mark Word在默认情况下存储着对象的HashCode、分代年龄、锁标记位等以下是32位JVM的Mark Word默认存储结构
锁状态	25bit	4bit	1bit是否是偏向锁	2bit 锁标志位
无锁状态	对象HashCode	对象分代年龄	0	01

其中轻量级锁和偏向锁是Java 6 对 synchronized 锁进行优化后新增加的，稍后我们会简要分析。这里我们主要分析一下重量级锁也就是通常说synchronized的对象锁，锁标识位为10，其中指针指向的是monitor对象（也称为管程或监视器锁）的起始地址。每个对象都存在着一个 monitor 与之关联，对象与其 monitor 之间的关系有存在多种实现方式，如monitor可以与对象一起创建销毁或当线程试图获取对象锁时自动生成，但当一个 monitor 被某个线程持有后，它便处于锁定状态。在Java虚拟机(HotSpot)中，monitor是由ObjectMonitor实现的，其主要数据结构如下（位于HotSpot虚拟机源码ObjectMonitor.hpp文件，C++实现的）
ObjectMonitor中有两个队列，_WaitSet 和 _EntryList，用来保存ObjectWaiter对象列表( 每个等待锁的线程都会被封装成ObjectWaiter对象)，_owner指向持有ObjectMonitor对象的线程，当多个线程同时访问一段同步代码时，首先会进入 _EntryList 集合，当线程获取到对象的monitor 后进入 _Owner 区域并把monitor中的owner变量设置为当前线程同时monitor中的计数器count加1，若线程调用 wait() 方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入 WaitSe t集合中等待被唤醒。若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)。如下图所示
由此看来，monitor对象存在于每个Java对象的对象头中(存储的指针的指向)，synchronized锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因，同时也是notify/notifyAll/wait等方法存在于顶级对象Object中的原因(关于这点稍后还会进行分析)，ok~，有了上述知识基础后，下面我们将进一步分析synchronized在字节码层面的具体语义实现。
2.关键字volatile

3.锁的分类
乐观锁和悲观锁
独占锁和共享锁
互斥锁和读写锁
公平锁和非公平锁
可重入锁  自旋锁  分段锁
- 锁升级
JDK1.6 为了提升性能减少获得锁和释放锁所带来的消耗，引入了4种锁的状态：无锁、偏向锁、轻量级锁和重量级锁，它会随着多线程的竞争情况逐渐升级，但不能降级。
- 无锁
无锁状态其实就是上面讲的乐观锁，这里不再赘述。
- 偏向锁
Java偏向锁(Biased Locking)是指它会偏向于第一个访问锁的线程，如果在运行过程中，只有一个线程访问加锁的资源，不存在多线程竞争的情况，那么线程是不需要重复获取锁的，这种情况下，就会给线程加一个偏向锁。
偏向锁的实现是通过控制对象Mark Word的标志位来实现的，如果当前是可偏向状态，需要进一步判断对象头存储的线程 ID 是否与当前线程 ID 一致，如果一致直接进入。
注：如果不加偏向锁，那么一个线程进入同步块时需要重复获取锁，有很大获取锁的开销；如果对象的锁状态是偏向锁，并且当前线程是持有偏向锁的线程，那么JVM会直接让线程进入同步块，无需额外的同步操作
- 轻量级锁
当线程竞争变得比较激烈时，偏向锁就会升级为轻量级锁，轻量级锁认为虽然竞争是存在的，但是理想情况下竞争的程度很低，通过自旋方式等待上一个线程释放锁。
注：如果在撤销偏向锁的过程中，JVM发现除了持有偏向锁的线程外，没有其他线程竞争该锁，那么JVM会将偏向锁状态转换为轻量级锁状态（偏向锁转轻量级锁）
- 重量级锁
如果线程并发进一步加剧，线程的自旋超过了一定次数，或者一个线程持有锁，一个线程在自旋，又来了第三个线程访问时（反正就是竞争继续加大了），轻量级锁就会膨胀为重量级锁，重量级锁会使除了此时拥有锁的线程以外的线程都阻塞。
升级到重量级锁其实就是互斥锁了，一个线程拿到锁，其余线程都会处于阻塞等待状态。
注：如果在撤销偏向锁的过程中，JVM发现除了持有偏向锁的线程外，还有其他线程竞争该锁，那么JVM会将偏向锁状态转换为重量级锁状态。此时，JVM会先暂停持有偏向锁的线程，并尝试使用CAS操作将对象的Mark Word替换为指向重量级锁的数据结构。（偏向锁转重量级锁）
在 Java 中，synchronized 关键字内部实现原理就是锁升级的过程：无锁 --> 偏向锁 --> 轻量级锁 --> 重量级锁。这一过程在后续讲解 synchronized 关键字的原理时会详细介绍
4.锁优化技术（锁粗化、锁消除）

锁粗化就是将多个同步块的数量减少，并将单个同步块的作用范围扩大，本质上就是将多次上锁、解锁的请求合并为一次同步请求。
举个例子，一个循环体中有一个代码同步块，每次循环都会执行加锁解锁操作
```
private static final Object LOCK = new Object();
for (int i=0;i<100;i++) {
            synchronized (LOCK) {
                //do something
            }
        }
```
```
private static final Object LOCK = new Object();
synchronized (LOCK) {
            for (int i=0;i<100;i++) {
                
            }
        }
```
锁消除
锁消除是指虚拟机编译器在运行时检测到了共享数据没有竞争的锁，从而将这些锁进行消除
上面代码中有一个 test 方法，主要作用是将字符串 s1 和字符串 s2 串联起来。
test 方法中三个变量s1, s2, stringBuffer， 它们都是局部变量，局部变量是在栈上的，栈是线程私有的，所以就算有多个线程访问 test 方法也是线程安全的。
我们都知道 StringBuffer 是线程安全的类，append 方法是同步方法，但是 test 方法本来就是线程安全的，为了提升效率，虚拟机帮我们消除了这些同步锁，这个过程就被称为锁消除。
```
public String test(String s1,String s2) {
        StringBuffer stringBuilder = new StringBuffer();
        stringBuilder.append(s1);
        stringBuilder.append(s2);
        return stringBuilder.toString();
    }
```

二、CAS

CAS存在三大问题：ABA问题，循环时间长且开销大，以及只能保证一个共享变量的原子操作；
ABA问题的场景如下：

1.初始状态，共享变量的值为A。
2.线程1读取共享变量的值A。
3.在线程1读取值A的同时，线程2将共享变量的值从A修改为B，然后又修改回A。
4.线程1执行CAS操作，比较共享变量的值为A，发现与预期值相等，于是进行更新操作。
在这种情况下，CAS操作成功，因为线程1读取共享变量时，发现其值与预期值相等。然而，实际上共享变量的值已经发生了变化，虽然在值的变化过程中经历了A->B->A的变化，但是线程1并不知道这个过程，它仅仅是关注共享变量的当前值与预期值是否相等。

这就是ABA问题，CAS操作成功，但忽略了共享变量的值在过程中发生了其他变化。ABA问题可能导致一些潜在的风险和错误，特别是在并发数据结构和多线程算法中使用CAS时。

为了解决ABA问题，可以使用版本号或标记来跟踪共享变量的变化。每次共享变量发生变化时，版本号或标记也会相应地增加。这样，在CAS操作时，不仅要比较值是否相等，还要比较版本号或标记是否匹配。如果版本号或标记不匹配，说明共享变量在过程中发生了变化，CAS操作将失败。

**如果修改失败如何解决**：
1.自旋重试：在获取失败后，可以使用自旋重试的方式，即反复尝试执行CAS操作，直到获取成功或达到一定的尝试次数或时间限制。自旋重试避免了线程的上下文切换，适用于短时间内锁竞争不激烈的情况。
2.适当延迟：为了减少不必要的CPU自旋消耗，在获取失败后可以适当地引入延迟。可以使用Thread.sleep()等方法在重试之前让线程进行短暂的休眠，以降低CPU占用。
3.加锁：如果CAS操作失败的次数较多或存在激烈的竞争情况，可以考虑使用传统的加锁机制，如使用synchronized关键字或ReentrantLock，来保证线程的互斥访问。加锁可以避免无限自旋的情况，但也会引入线程的上下文切换和额外的开销。
4.采用其他策略：根据具体的业务场景和需求，还可以采用其他策略来处理CAS获取失败的情况。例如，可以选择放弃当前操作、回退到其他实现方式，或者根据具体情况进行异常处理等。

二、为什么频繁创建线程会需要时间，具体那部分的时间

线程分为守护线程和非守护线程
当Java程序的所有非守护线程都执行完毕时，程序会正常退出，无论是否还存在守护线程。非守护线程是程序的主要执行线程，它们执行程序的核心逻辑。一旦所有非守护线程执行完毕，JVM会自动退出，无需显式地停止守护线程。

然而，如果还存在活跃的非守护线程，程序仍然可以继续执行。在这种情况下，守护线程的行为会有所影响。

守护线程是一类特殊的线程，它的生命周期与非守护线程不同。当程序中只剩下守护线程时，JVM会判断程序已经不再需要继续执行，因此会强制终止所有守护线程，然后退出程序。

三、JMM
JMM（Java Memory Model）是Java中定义的一种抽象的内存模型，用于规定多线程程序在访问共享变量时的行为。JMM定义了线程如何与主内存和工作内存进行交互，以及如何保证多线程程序的可见性、有序性和原子性。

以下是JMM的主要特点和规则：

1.主内存（Main Memory）：主内存是所有线程共享的内存区域，包含了所有的共享变量。

2.工作内存（Working Memory）：每个线程都有自己的工作内存，工作内存存储了线程使用到的变量的副本。线程对共享变量的操作都先在工作内存中进行，然后根据一定的规则将结果同步到主内存或其他线程的工作内存中。

3.内存间的交互操作：线程之间的变量值传递必须通过主内存来完成。一个线程对共享变量的写操作，必须先将值写入自己的工作内存，然后再将修改同步到主内存中。另一个线程对共享变量的读操作，必须先从主内存中读取最新的值到自己的工作内存，然后再进行读取。

4.原子性（Atomicity）：JMM保证对基本数据类型（如int、long）的读写操作具有原子性，即一个线程的读写操作不会被其他线程干扰。但对于复合操作，如i++这样的自增操作，并不具有原子性。

5.可见性（Visibility）：JMM保证一个线程对共享变量的修改对其他线程是可见的。当一个线程对共享变量进行修改后，必须将修改后的值同步到主内存中，然后其他线程才能读取到最新的值。

6.有序性（Ordering）：JMM保证程序的执行顺序符合代码的顺序。但在多线程环境下，由于指令重排序等优化，可能导致线程执行的顺序与代码编写的顺序不一致。JMM通过禁止某些类型的重排序来保证有序性。

JMM通过使用各种同步机制（如volatile、synchronized、Lock等）和内存屏障（Memory Barrier）等手段来实现上述特点和规则，从而保证多线程程序的正确性和可靠性。开发者在编写多线程程序时，需要遵循JMM的规则，合理使用同步机制和内存屏障，以确保线程安全性和正确的内存访问

四、happen-before
JMM（Java Memory Model）和happen-before 是相关的概念，用于描述多线程程序中操作之间的顺序关系。
JMM定义了操作之间的happen-before关系，它是一种偏序关系，用于描述在多线程环境中，一个操作的执行结果对于其他操作的可见性和有序性。
以下是JMM中的happen-before规则：
程序顺序规则（Program Order Rule）：在单个线程中，按照程序的顺序，前面的操作happen-before后面的操作。
锁定规则（Lock Rule）：一个解锁操作happen-before对同一个锁的后续加锁操作。
volatile变量规则（Volatile Variable Rule）：对一个volatile变量的写操作happen-before后续对该变量的读操作。
传递性规则（Transitive Rule）：如果操作A happen-before操作B，操作B happen-before操作C，那么操作A happen-before操作C。
线程启动规则（Thread Start Rule）：线程的启动操作happen-before线程中的任何操作。
线程终止规则（Thread Termination Rule）：线程的所有操作happen-before其他线程检测到该线程的终止。
中断规则（Interruption Rule）：一个线程中的中断发生happen-before其他线程检测到该线程的中断事件。
这些规则定义了操作之间的顺序关系，通过happen-before关系，JMM保证了多线程程序的可见性和有序性。根据happen-before关系，对一个操作的执行结果对于其他操作的可见性是有保证的，因为后续的操作会看到先前操作的结果。同时，happen-before关系也保证了操作的执行顺序符合代码的顺序，避免了指令重排序等问题。
开发者可以利用happen-before关系来编写正确的多线程程序，通过合理地使用同步机制（如锁、volatile变量、synchronized等）来确保操作的happen-before关系符合预期，从而保证线程安全性和正确的内存访问。

五、Store Buffer与
Store Buffer（写缓冲）是现代处理器中的一种优化技术，用于延迟写入操作并提高内存访问的效率。Store Buffer允许处理器将写操作暂时缓存到一个专门的缓冲区，而不是立即将数据写入主内存。
Store Buffer能够延迟写入的原因有以下几点：
提高处理器的吞吐量：将写操作暂时缓存到Store Buffer中可以减少对内存的访问次数，从而提高处理器的吞吐量。处理器可以继续执行后续的指令，而不需要等待写操作完成。
减少内存访问延迟：内存访问通常是一项较为耗时的操作，通过将写操作缓存到Store Buffer中，可以减少对主内存的直接访问，从而减少内存访问延迟，提高程序的执行效率。
优化写操作的顺序：Store Buffer可以对写操作进行重排序，以优化写操作的执行顺序。重排序可以提高处理器的性能，例如通过合并多个写操作到同一个内存区域，减少内存总线的竞争。
Store Buffer解决了多线程程序中的内存可见性问题。当一个线程执行写操作时，修改的数据首先会被存储到Store Buffer中，而不是立即写入主内存。其他线程在读取该共享变量时，可能会从自己的工作内存中读取旧的值，而不是最新的值。然而，Store Buffer会定期将缓存的数据刷新到主内存中，从而确保对共享变量的修改对其他线程是可见的。
因此，Store Buffer在多线程环境中起到了延迟写入和优化内存访问的作用。它通过提高处理器的吞吐量、减少内存访问延迟和优化写操作顺序，提高了程序的性能。同时，它通过刷新缓存数据到主内存，解决了多线程程序中的内存可见性问题，确保线程之间对共享变量修改的可见性。


- 修改的数据首先会被存储到Store Buffer中，而不是立即写入主内存 不会导致其他线程脏读吗
Store Buffer 的延迟写入特性可能会导致其他线程发生脏读的情况。
当一个线程执行写操作时，修改的数据首先会被存储到 Store Buffer 中，而不是立即写入主内存。如果其他线程在此时读取共享变量，它们可能会从自己的工作内存中读取旧的值，而不是最新的值。这种情况下就会发生脏读，即读取到了尚未写入主内存的数据。
为了解决脏读的问题，现代处理器采用了一些机制来确保内存的一致性和可见性。其中一个常用的机制是**内存屏障**（Memory Barrier）或者称为内存栅栏（Memory Fence）。内存屏障是一种同步操作，它可以保证在内存屏障之前的所有写操作在屏障之后的读操作之前完成。
内存屏障可以用来解决 Store Buffer 导致的脏读问题。当一个线程执行 Store Buffer 刷新到主内存的操作时，在刷新之前插入一个内存屏障，确保在该内存屏障之前的所有写操作在屏障之后的读操作之前完成。这样，其他线程在读取共享变量时，会从主内存中获取最新的值，避免了脏读的问题。
需要注意的是，具体的内存屏障机制和实现可能因处理器架构和编程语言的不同而有所差异。在编写多线程程序时，开发人员应该使用合适的同步机制（如锁、volatile变量、synchronized等）来确保内存的一致性和可见性，以避免脏读和其他内存访问问题。


六、DCL（Double-Checked Locking）
DCL（Double-Checked Locking）是一种用于实现延迟初始化的线程安全单例模式的技术。它的目标是在保持高性能的同时，确保只有一个实例被创建。

DCL的基本思想是在锁的粒度上进行优化。它使用两个检查来减少对共享资源的同步访问。首先，通过检查实例是否已经被创建，避免了大部分的同步开销。其次，在需要创建实例时，使用同步块来确保只有一个线程创建实例。

以下是DCL的基本实现模式：
```
public class Singleton {
    private static Singleton instance;

    private Singleton() {
        // 私有构造函数
    }

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                // 此处代码有问题
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```
在第一次调用getInstance()方法时，会进行第一次检查，如果实例已经存在，则直接返回实例，避免了不必要的同步开销。如果实例不存在，则进入同步块，在同步块中再次检查实例是否已经被创建，以防止多个线程同时通过了第一次检查。如果实例仍然为null，才会创建实例。
需要注意的是，DCL需要保证instance变量是volatile类型，以确保其在多线程环境下的可见性。此外，DCL在某些特定的平台或编译器上可能存在问题，例如指令重排序导致的安全性问题。为了解决这些问题，可以使用其他的延迟初始化技术，如静态内部类实现单例模式或者使用线程安全的饿汉式单例等。

上述的 instance = new Singleton(); 代码有问题：其底层会分为三个操作：
1. 分配⼀块内存。
2. 在内存上初始化成员变量。
3. 把instance引⽤指向内存。
在这三个操作中，操作2和操作3可能重排序，即先把instance指向内存，再初始化成员变量，因为⼆者并没有先后的依赖关系。此时，另外⼀个线程可能拿到⼀个未完全初始化的对象。这时，直接访问⾥⾯的成员变量，就可能出错。这就是典型的“构造⽅法溢出”问题。

解决办法也很简单，就是为instance变量加上volatile修饰。
volatile的三重功效：64位写⼊的原⼦性、内存可⻅性和禁⽌重排序。
volatile 关键字只保证了对变量的读写操作的可见性和顺序性，并不保证原子性。如果需要保证原子性，可以考虑使用其他同步机制，如锁或原子类

[面试官：Java线程与底层操作系统线程是一 一对应的吗? 中篇[一]_mob60475706bec5的技术博客_51CTO博客](https://blog.51cto.com/u_15127698/2842977)
