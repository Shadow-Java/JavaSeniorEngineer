## 1 Java数据类型

java数据分为两种：基本数据类型（Primitive Type）和引用数据类型（Reference Type）

![basicdatatype.png](./assets/basic-data-type.png)

### 1.1 基本数据类型

* byte（字节型）   1字节（8位），数据范围是 -2^7 ~ 2^7-1
* boolean（布尔型） 1字节
* short（短整型）  2字节（16位），数据范围是 -2^15 ~ 2^15-1
* char：2字节（16位） 实际上字符型也是一种**整数类型**，相当于无符号整数类型
* int（整型） 4字节  数据范围是 -2^31 ~ 2^31-1
* float（单精度浮点型） 4字节，数据范围大约是 -3.4*10^38 ~ 3.4*10^38
* long（长整型）  8字节（64位），数据范围是 -2^63 ~ 2^63-1
* double （双精度浮点型） 8字节（64位），数据范围大约是 -1.8*10^308 ~ 1.8*10^308

> 应用场景：一般的数据处理，但没有经过包装，不能调用函数，float数字必须f或F结尾

### 1.2 引用类型

* 类
* 接口
* 数组

```java
public static void swap(int a,int b){//为什么没有交换成功
        int temp = a;
        a = b;
        b = temp;
    }
```

> 应用场景：类似于c++中的指针，所以在数组中方法传参是会改变值的，但是基本数据类型就不会

> 注意：空引用（null）只能被转换成引用类型，不能转换成基本类型，因此不要把一个 null 值赋给基本数据类型的变量。

#### 1.2.1四种引用类型(JVM中会讲)

* 强引用

强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。

```java
Object o=new Object();   //  强引用
```

* 软引用
* 弱引用
* 虚引用

---

## 2 变量与常量

Java支持的变量类型有：成员变量和局部变量

### 2.1 成员变量

```java
public class Variable{
    static int allClicks=0;    // 类变量

    String str="hello world";  // 实例变量

    public void method(){

        int i =0;  // 局部变量
    }
}
```

1. 类变量（静态变量，也称常量）

> 独立于方法之外，用static修饰；存储于方法区中，生命周期与当前类相同；`为什么是类变量，则需要看完JVM的对象生命周期`
> 无论创建多少对象，对象只拥有类变量的一份拷贝
> 生命周期：静态变量在第一次被访问时创建，在程序结束时销毁
> 默认值和实例变量相似。数值型变量默认值是 0，布尔型默认值是 false，引用类型默认值是 null。

2. 实例变量（类中的全局变量）

> 独立于方法之外的变量，没有static修饰；存储在堆中生命周期与对象相同

> 实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；
> 生命周期：在对象创建时创建，在对象销毁时销毁

### 2.2 局部变量

1. 声明在方法、构造方法或者语句块中,在方法、构造方法、或者语句块 **被执行的时候创建** ，当它们**执行完成后，变量将会被销毁**
2. 如果方法体中传递的不是引用类型，则只会值传递，而不会改变方法体外的变量值
3. **没有默认值** ，所以局部变量被声明后， **必须经过初始化** ，才可以使用

### 2.3 常量（JVM中有详细解释）

常量通常也被称为`final变量`，在整个程序中只会被分配一次，为所有对象共享

定义类型：`final 数据类型 常量名称（=值）

#### 2.3.1 编译时常量

如：

```java
private final static String UER_NAME = "shadow";
```

不需要在运行时确定，即编译期类不会初始化，你可以当做这常量是独立的，不会依赖类

#### 2.3.2 运行时常量

```java
private final static Integer UER_NAME_LENGTH = "shadow".length();
```

运行时才会确定，即需要类的初始化才会完成

#### 2.3.3 区别

编译期常量如果更改，那么所有引用到该常量的文件都需要更改；如果是运行时常量，则不需要

比如定义不是内部类文件dog和cat，cat引用dog的编译期常量，一旦dog修改值，用javac编译，cat依旧是旧值

所以推荐常量使用enum，不用整个再次编译（有待证实，没有部署图床，所以没写代码）

---

## 3 修饰符

Java中无法引用没有包、默认包和顶级类，`顶级类导入只能由另一个顶级类导入`

### 3.1 public

* 公共的，对象可以任意地方被调用
* 且该修饰的方法、变量能够被继承

### 3.2 private

私有的，只能在同一个类中被访问；且该修饰的方法、变量不能被继承

### 3.3 protected（继承访问权限）

* protected 可以修饰数据成员，构造方法，方法成员，`不能修饰类（内部类除外）`
* `接口及接口的成员变量和成员方法`不能声明为 protected
* 保护的意思就是 保护我的家人，只能跟我有继承关系的人才能访问

  使用场景：继承父类的protected的函数或变量，对于其他成员是private，所以主要用于代码的简洁性，顺序执行的代码

### 3.4 default(同级包访问权限)

* 默认的，即包权限，默认能被同一个包下的类访问
* 不管是都是继承，只要不在同一个包下，则不能被访问

### 3.5 非访问修饰符

底层原理将在JDK源码中查看

#### 3.5.1 static (静态修饰符)

1. 用于修饰方法和变量，且方法和变量的生命周期跟类一致，不管创建多少实例对象且只有一份拷贝，`不能修饰类`；静态变量主要配合final+static使用，可以使用类访问
2. 对于static方法不能含有非静态成员的变量或方法，因为static是在类加载时初始化，而非静态则需要具体的对象才能调用

##### 3.5.1.1 使用场景

1.加载机制不同

静态变量是被所有对象所共享，在内存中只有一个副本，是在类初次加载的时候初始化

非静态变量是类产生的多个对象每人一份，创建对象的时候初始化

> 加载机制不同，所有频繁使用的变量可以用静态变量

2.static块

根据加载机制不同，定义个static块可以更快的初始化需要的`静态对象`；类中可以有多个static块，在类每次加载时，按照顺序执行。

> 注意：static不能修饰局部变量，且static不会改变访问权限

3.初始化加载顺序

父类静态成员变量->父类静态代码块->子类静态成员变量->子类静态代码块->父类非静态成员变量->

父类非静态代码块->父类构造函数->子类非静态成员变量->子类非静态代码块->子类构造函数

#### 3.5.2 final（最终的）

1. 可以修饰类、方法和变量（包括成员变量和局部变量）
2. 修饰类时表明是最终的，即不可继承
3. 修饰变量时，如果是基本数据类型，则初始化后不可更改，如果是引用数据类型，则初始化后不能再指向其他的对象（不能再被赋值）

   ```java
   final String s = "abd";//final修饰的是引用变量，但指向的对象内容是可变的
            s = "sdf";//错误}
   ```

   ```java
   String s = "abd";//final修饰的是类String，而没修饰变量引用s，所以引用是可变的
            s = "sdf";//正确
   ```

   第二个为什么是正确的，主要在于String s只是一个对象的引用，不是对象；而”abd“字符串一直在常量池中
4. final会对编译期做常量优化，相当于直接访问这个变量，不需要在运行时确定

##### 3.5.2.1 使用场景

如果处于`安全和效率`考虑可以采用final，如string

#### 3.5.3 abstract

功能是定义一个`抽象类`，abstract和interface类似，主要是区分编程中的`概念

##### 3.5.3.1 abstract class 和 interface

> 比如需要设计一个动物，动物能够吃喝，然后对动物可以进行拓展，比如猫与狗；所以动物就是抽象，吃喝就是抽象方法，因为不是对应具体的人

> 这种动物最好是用abstract class（猫是动物的子类，所以不用interface），而不是用interface，因为Java是单一继承，多实现。

> 如果动物还要能够骑车或赛马，则可以用interface，因为不是所有的动物都能骑车；

##### 3.5.3.2 abstract class

1. 不能被实例化，因为是抽象的，所以不能new
2. 可以有变量和方法，方法可以是抽象的和非抽象的，且抽象方法不能具体实现
3. 抽象方法不能声明成static和final
4. 如果子类不是抽象类，则必须实现父类的所有抽象方法；如果子类是抽象类，则不用

##### 3.5.3.3 abstract interface

abstract对于接口来说是多余的，一般不这么使用

#### 3.5.4 synchronized 与 volatile

在高并发与多线程中

## 4 运算符

### 4.1 关系运算符

简单，自己百度

### 4.2 位运算符（主要用于算法）


| 类型     | &        | 或       | ^       | ~    | <<                          | >>                 | >>>                  |
| ---------- | ---------- | ---------- | --------- | ------ | ----------------------------- | -------------------- | ---------------------- |
| 名称     | 与       | 或       | 异或    | 取反 | 左移                        | 右移               | 无符号右移           |
| 按位操作 | 都是1置1 | 都是0置0 | 不同置1 | 取反 | 5<<2左移两位，类似于乘法5*4 | 5>>2右移两位，除法 | 5>>>2,无符号右移两位 |


* ">>>"

无符号右移，移动之后由0填充

* ">>"

有符号右移，移动之后由左边的符号位填充

* "<<"

有符号左移，移动之后右边末尾由0填充



### 4.3 instanceof 运算符

用于判断一个对象是否是一个特定的类型`( Object reference variable ) instanceof  (class/interface type)`

```
boolean type = shadow instanceof String; // 判断 shadow是 String 类型，所以返回真
```
