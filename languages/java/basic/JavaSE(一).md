# Java编程语言概述

# Java基础语法

# Java数组

# 面向对象编程

# 高级类特性

# Java API

# 异常处理

# 集合与泛型

# Java IO流

# Java多线程

# Java Reflection（Java反射）

# 网络编程

# Java8 新特性

# Java9/Java10/Java11新特性

# JavaSE项目

## 1 Java数据类型

java数据分为两种：基本数据类型（Primitive Type）和引用数据类型（Reference Type）

![basicdatatype.png](./assets/basic-data-type.png)

### 1.1 基本数据类型

* byte（字节型）   1字节（8位），数据范围是 -2^7 ~ 2^7-1
* boolean（布尔型） 1字节
* short（短整型）  2字节（16位），数据范围是 -2^15 ~ 2^15-1
* char：2字节（16位） 实际上字符型也是一种**整数类型**，相当于无符号整数类型
* int（整型） 4字节  数据范围是 -2^31 ~ 2^31-1
* float（单精度浮点型） 4字节，数据范围大约是 -3.4*10^38 ~ 3.4*10^38
* long（长整型）  8字节（64位），数据范围是 -2^63 ~ 2^63-1
* double （双精度浮点型） 8字节（64位），数据范围大约是 -1.8*10^308 ~ 1.8*10^308

> 应用场景：一般的数据处理，但没有经过包装，不能调用函数，float数字必须f或F结尾

### 1.2 引用类型

* 类
* 接口
* 数组

```java
public static void swap(int a,int b){//为什么没有交换成功
        int temp = a;
        a = b;
        b = temp;
    }
```

> 应用场景：类似于c++中的指针，所以在数组中方法传参是会改变值的，但是基本数据类型就不会

> 注意：空引用（null）只能被转换成引用类型，不能转换成基本类型，因此不要把一个 null 值赋给基本数据类型的变量。

#### 1.2.1四种引用类型(JVM中会讲)

* 强引用

强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。

```java
Object o=new Object();   //  强引用
```

* 软引用
* 弱引用
* 虚引用

---

## 2 变量

Java支持的变量类型有：成员变量和局部变量

### 2.1 成员变量

```java
public class Variable{
    static int allClicks=0;    // 类变量

    String str="hello world";  // 实例变量

    public void method(){

        int i =0;  // 局部变量
    }
}
```

1. 类变量（静态变量）

> 独立于方法之外，用static修饰；存储于方法区中，生命周期与当前类相同；`为什么是类变量，则需要看完JVM的对象生命周期`
> 无论创建多少对象，对象只拥有类变量的一份拷贝
> 生命周期：静态变量在第一次被访问时创建，在程序结束时销毁
> 默认值和实例变量相似。数值型变量默认值是 0，布尔型默认值是 false，引用类型默认值是 null。

2. 实例变量（类中的全局变量）

> 独立于方法之外的变量，没有static修饰；存储在堆中生命周期与对象相同

> 实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；
> 生命周期：在对象创建时创建，在对象销毁时销毁

### 2.2 局部变量

在方法体中的变量

---



## 3 修饰符

Java中无法引用没有包、默认包和顶级类，`顶级类导入只能由另一个顶级类导入`

### 3.1 public

* 公共的，对象可以任意地方被调用
* 且该修饰的方法、变量能够被继承

### 3.2 private

私有的，只能在同一个类中被访问；且该修饰的方法、变量不能被继承

### 3.3 protected（继承访问权限）

* protected 可以修饰数据成员，构造方法，方法成员，`不能修饰类（内部类除外）`
* `接口及接口的成员变量和成员方法`不能声明为 protected
* 保护的意思就是 保护我的家人，只能跟我有继承关系的人才能访问

  使用场景：继承父类的protected的函数或变量，对于其他成员是private，所以主要用于代码的简洁性，顺序执行的代码

### 3.4 default(同级包访问权限)

* 默认的，即包权限，默认能被同一个包下的类访问
* 不管是都是继承，只要不在同一个包下，则不能被访问

### 3.5 非访问修饰符

底层原理将在JDK源码中查看

#### 3.5.1 static (静态修饰符)

1. 用于修饰方法和变量，且方法和变量的生命周期跟类一致，不管创建多少实例对象且只有一份拷贝，`不能修饰类`；静态变量主要配合final+static使用，可以使用类访问
2. 对于static方法不能含有非静态成员的变量或方法，因为static是在类加载时初始化，而非静态则需要具体的对象才能调用

##### 3.5.1.1 使用场景

1.加载机制不同

静态变量是被所有对象所共享，在内存中只有一个副本，是在类初次加载的时候初始化

非静态变量是类产生的多个对象每人一份，创建对象的时候初始化

> 加载机制不同，所有频繁使用的变量可以用静态变量

2.static块

根据加载机制不同，定义个static块可以更快的初始化需要的`静态对象`；类中可以有多个static块，在类每次加载时，按照顺序执行。

> 注意：static不能修饰局部变量，且static不会改变访问权限

3.初始化加载顺序

父类静态成员变量->父类静态代码块->子类静态成员变量->子类静态代码块->父类非静态成员变量->

父类非静态代码块->父类构造函数->子类非静态成员变量->子类非静态代码块->子类构造函数

#### 3.5.2 final（最终的）

1. 可以修饰类、方法和变量（包括成员变量和局部变量）
2. 修饰类时表明是最终的，即不可继承
3. 修饰变量时，如果是基本数据类型，则初始化后不可更改，如果是引用数据类型，则初始化后不能再指向其他的对象（不能再被赋值）

   ```java
   final String s = "abd";//final修饰的是引用变量，但指向的对象内容是可变的
            s = "sdf";//错误}
   ```

   ```java
   String s = "abd";//final修饰的是类String，而没修饰变量引用s，所以引用是可变的
            s = "sdf";//正确
   ```

   第二个为什么是正确的，主要在于String s只是一个对象的引用，不是对象；而”abd“字符串一直在常量池中
4. final会对编译期做常量优化，相当于直接访问这个变量，不需要在运行时确定

##### 3.5.2.1 使用场景

对于类，如果处于安全和效率考虑可以采用final，如string

#### 3.5.3 abstract



#### 3.5.4 synchronized 与 volatile

在高并发与多线程中
