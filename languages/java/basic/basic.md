## 1 Java数据类型

java数据分为两种：基本数据类型（Primitive Type）和引用数据类型（Reference Type）

![basicdatatype.png](./assets/basic-data-type.png)

### 1.1 基本数据类型

* byte（字节型）   1字节（8位），数据范围是 -2^7 ~ 2^7-1
* boolean（布尔型） 1字节
* short（短整型）  2字节（16位），数据范围是 -2^15 ~ 2^15-1
* char：2字节（16位） 实际上字符型也是一种**整数类型**，相当于无符号整数类型
* int（整型） 4字节  数据范围是 -2^31 ~ 2^31-1
* float（单精度浮点型） 4字节，数据范围大约是 -3.4*10^38 ~ 3.4*10^38
* long（长整型）  8字节（64位），数据范围是 -2^63 ~ 2^63-1
* double （双精度浮点型） 8字节（64位），数据范围大约是 -1.8*10^308 ~ 1.8*10^308

> 应用场景：一般的数据处理，但没有经过包装，不能调用函数，float数字必须f或F结尾

### 1.2 引用类型

* 类
* 接口
* 数组

```java
public static void swap(int a,int b){//为什么没有交换成功
        int temp = a;
        a = b;
        b = temp;
    }
```

> 应用场景：类似于c++中的指针，所以在数组中方法传参是会改变值的，但是基本数据类型就不会

> 注意：空引用（null）只能被转换成引用类型，不能转换成基本类型，因此不要把一个 null 值赋给基本数据类型的变量。

#### 1.2.1四种引用类型(JVM中会讲)

* 强引用

强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。

```java
Object o=new Object();   //  强引用
```

* 软引用
* 弱引用
* 虚引用

---

## 2 变量与常量

Java支持的变量类型有：成员变量和局部变量

### 2.1 成员变量

```java
public class Variable{
    static int allClicks=0;    // 类变量

    String str="hello world";  // 实例变量

    public void method(){

        int i =0;  // 局部变量
    }
}
```

1. 类变量（静态变量，也称常量）

> 独立于方法之外，用static修饰；存储于方法区中，生命周期与当前类相同；`为什么是类变量，则需要看完JVM的对象生命周期`
> 无论创建多少对象，对象只拥有类变量的一份拷贝
> 生命周期：静态变量在第一次被访问时创建，在程序结束时销毁
> 默认值和实例变量相似。数值型变量默认值是 0，布尔型默认值是 false，引用类型默认值是 null。

2. 实例变量（类中的全局变量）

> 独立于方法之外的变量，没有static修饰；存储在堆中生命周期与对象相同

> 实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；
> 生命周期：在对象创建时创建，在对象销毁时销毁

### 2.2 局部变量

1. 声明在方法、构造方法或者语句块中,在方法、构造方法、或者语句块 **被执行的时候创建** ，当它们**执行完成后，变量将会被销毁**
2. 如果方法体中传递的不是引用类型，则只会值传递，而不会改变方法体外的变量值
3. **没有默认值** ，所以局部变量被声明后， **必须经过初始化** ，才可以使用

### 2.3 常量（JVM中有详细解释）

常量通常也被称为`final变量`，在整个程序中只会被分配一次，为所有对象共享

定义类型：`final 数据类型 常量名称（=值）

#### 2.3.1 编译时常量

如：

```java
private final static String UER_NAME = "shadow";
```

不需要在运行时确定，即编译期类不会初始化，你可以当做这常量是独立的，不会依赖类

#### 2.3.2 运行时常量

```java
private final static Integer UER_NAME_LENGTH = "shadow".length();
```

运行时才会确定，即需要类的初始化才会完成

#### 2.3.3 区别

编译期常量如果更改，那么所有引用到该常量的文件都需要更改；如果是运行时常量，则不需要

比如定义不是内部类文件dog和cat，cat引用dog的编译期常量，一旦dog修改值，用javac编译，cat依旧是旧值

所以推荐常量使用enum，不用整个再次编译（有待证实，没有部署图床，所以没写代码）

### 2.4 字面量与引用（JVM中有详细解释）

* 字面量(literal)

就是字面的意思,字面量是对int、float、double、boolean、char、String字符串和null的

```java
int i = 1;把整数1赋值给int型变量i，整数1就是Java字面量，
String s = "abc";//中的abc也是字面量。
Object o = null;//null是字面量
```

* 符号引用（Symbolic References）

  * 类和接口的全限定名（Fully Qualified Name）
  * 字段的名称和描述符（Descriptor）
  * 方法的名称和描述符
* 直接引用

  * 直接指向目标的指针（比如，指向“类型”【Class对象】、类变量、类方法的直接引用可能是指向方法区的指针）
  * 相对偏移量（比如，指向实例变量、实例方法的直接引用都是偏移量）
  * 一个能间接定位到目标的句柄

---

## 3 修饰符

Java中无法引用没有包、默认包和顶级类，`顶级类导入只能由另一个顶级类导入`

### 3.1 public

* 公共的，对象可以任意地方被调用
* 且该修饰的方法、变量能够被继承

### 3.2 private

私有的，只能在同一个类中被访问；且该修饰的方法、变量不能被继承

### 3.3 protected（继承访问权限）

* protected 可以修饰数据成员，构造方法，方法成员，`不能修饰类（内部类除外）`
* `接口及接口的成员变量和成员方法`不能声明为 protected
* 保护的意思就是 保护我的家人，只能跟我有继承关系的人才能访问

  使用场景：继承父类的protected的函数或变量，对于其他成员是private，所以主要用于代码的简洁性，顺序执行的代码

### 3.4 default(同级包访问权限)

* 默认的，即包权限，默认能被同一个包下的类访问
* 不管是都是继承，只要不在同一个包下，则不能被访问

### 3.5 非访问修饰符

底层原理将在JDK源码中查看

#### 3.5.1 static (静态修饰符)

1. 用于修饰方法和变量，且方法和变量的生命周期跟类一致，不管创建多少实例对象且只有一份拷贝，`不能修饰类`；静态变量主要配合final+static使用，可以使用类访问
2. 对于static方法不能含有非静态成员的变量或方法，因为static是在类加载时初始化，而非静态则需要具体的对象才能调用

##### 3.5.1.1 使用场景

1.加载机制不同

静态变量是被所有对象所共享，在内存中只有一个副本，是在类初次加载的时候初始化

非静态变量是类产生的多个对象每人一份，创建对象的时候初始化

> 加载机制不同，所有频繁使用的变量可以用静态变量

2.static块

根据加载机制不同，定义个static块可以更快的初始化需要的`静态对象`；类中可以有多个static块，在类每次加载时，按照顺序执行。

> 注意：static不能修饰局部变量，且static不会改变访问权限

3.初始化加载顺序

父类静态成员变量->父类静态代码块->子类静态成员变量->子类静态代码块->父类非静态成员变量->

父类非静态代码块->父类构造函数->子类非静态成员变量->子类非静态代码块->子类构造函数

#### 3.5.2 final（最终的）

1. 可以修饰类、方法和变量（包括成员变量和局部变量）
2. 修饰类时表明是最终的，即不可继承
3. 修饰变量时，如果是基本数据类型，则初始化后不可更改，如果是引用数据类型，则初始化后不能再指向其他的对象（不能再被赋值）

   ```java
   final String s = "abd";//final修饰的是引用变量，但指向的对象内容是可变的
            s = "sdf";//错误}
   ```

   ```java
   String s = "abd";//final修饰的是类String，而没修饰变量引用s，所以引用是可变的
            s = "sdf";//正确
   ```

   第二个为什么是正确的，主要在于String s只是一个对象的引用，不是对象；而”abd“字符串一直在常量池中
4. final会对编译期做常量优化，相当于直接访问这个变量，不需要在运行时确定

##### 3.5.2.1 使用场景

如果处于`安全和效率`考虑可以采用final，如string

#### 3.5.3 abstract

功能是定义一个`抽象类`，abstract和interface类似，主要是区分编程中的`概念

##### 3.5.3.1 abstract class 和 interface

> 比如需要设计一个动物，动物能够吃喝，然后对动物可以进行拓展，比如猫与狗；所以动物就是抽象，吃喝就是抽象方法，因为不是对应具体的人

> 这种动物最好是用abstract class（猫是动物的子类，所以不用interface），而不是用interface，因为Java是单一继承，多实现。

> 如果动物还要能够骑车或赛马，则可以用interface，因为不是所有的动物都能骑车；

##### 3.5.3.2 abstract class

1. 不能被实例化，因为是抽象的，所以不能new
2. 可以有变量和方法，方法可以是抽象的和非抽象的，且抽象方法不能具体实现
3. 抽象方法不能声明成static和final
4. 如果子类不是抽象类，则必须实现父类的所有抽象方法；如果子类是抽象类，则不用

##### 3.5.3.3 abstract interface

abstract对于接口来说是多余的，一般不这么使用

#### 3.5.4 synchronized 与 volatile

在高并发与多线程中

3.5.5 this与super

* this指的是类创建的`实例对象`，即这个对象在堆上的`内存地址`，super是`父类的地址`，所以子类实例化时父类也会被实例化；
* this是指对象而不是类，所以static修饰的方法或变量，不能被引用
* 如果父类构造器是带有参数，那么子类的构造器必须显示的指明构造器的参数；如果父类是无参构造，则子类会自动调取父类构造器，不用指明super
* 类的构造函数可以不写，但系统会给你默认是无参构造
* 类的初始化顺序：

1. 父类静态成员和静态初始化块
2. 子类静态成员和静态初始化块
3. 父类实例成员和实例初始化块
4. 父类构造方法
5. 子类实例成员和实例初始化块
6. 子类构造方法

---

## 4 运算符

### 4.1 关系运算符

简单，自己百度

### 4.2 位运算符（主要用于算法）


| 类型     | &        | 或       | ^       | ~    | <<                          | >>                 | >>>                  |
| ---------- | ---------- | ---------- | --------- | ------ | ----------------------------- | -------------------- | ---------------------- |
| 名称     | 与       | 或       | 异或    | 取反 | 左移                        | 右移               | 无符号右移           |
| 按位操作 | 都是1置1 | 都是0置0 | 不同置1 | 取反 | 5<<2左移两位，类似于乘法5*4 | 5>>2右移两位，除法 | 5>>>2,无符号右移两位 |

* ">>>"

无符号右移，移动之后由0填充

* ">>"

有符号右移，移动之后由左边的符号位填充

* "<<"

有符号左移，移动之后右边末尾由0填充

### 4.3 instanceof 运算符

用于判断一个对象是否是一个特定的类型`( Object reference variable ) instanceof  (class/interface type)`

```
boolean type = shadow instanceof String; // 判断 shadow是 String 类型，所以返回真
```

## 5 Exception

程序并不会一直顺利执行，那么就经常会导致异常情况，异常类就能很好的解决这种情况。试想，如果没有异常会怎么样？
什么样的场景会使用异常？

![](https://picturestr.oss-cn-shanghai.aliyuncs.com/javaseniorengineer/language/java/basic/202204252148340.png)

### 5.1 产生异常情况

1. Java内部错误发生的异常、JVM虚拟机产生的异常；
2. 编写代码中错误产生的异常，如空指针、数组越界等；
3. 通过throw语句手动生成的异常，一般告知方法调用者的信息；

### 5.2 异常类型

Throwable是所有`异常（Exception）`和`错误（Error）`的超类，Error是程序无法处理的，大多数错误与代码编写者无关，一般是虚拟机出现的问题。

比如虚拟机运行异常（Virtual MachineError）、内存溢出异常（OutOfMemoryError）或是类定义错误（NoClassDefFoundError），这些错误都是不可查的，当你出现这些错误是不会被编译的。

程序分为**编译过程**（java文件->class字节码文件，javac.exe）和**运行过程**（内存加载类、执行类，java.exe），运行过程需要用到JVM的加载器和运行器运行程序，比如虚拟机自己就出错，这些都是JVM无法解决的问题，一般不会通过代码处理。

异常可以通过一般性代码提前预知处理，如果不处理就会导致程序的中止。异常的捕获（异常也是个类，需要捕获处理）最好是在编译期，但有些异常只有在运行时才会被发现。其中说的异常指的就是Exception，异常又分为运行时异常（RuntimeException，又称非受检异常，指编译不会检查）和非运行时异常（编译异常，又称受检异常，指编译会检查），所以非运行时异常比较严重，编译就不会通过生成不了字节码文件，即当你写代码时就报的异常就是编译时异常。

编译时异常有`IOException、ClssNotFoudException`等，运行时异常有`NullPointerException、ArrayIndexOutofBoundsException`等

### 5.3 异常处理方式

一般的程序可能会有很多的异常，如果每个用if-else规避这些异常就很繁琐冗余，java就给出了异常处理机制，即把可能出现异常得代码分成段，用{}包裹，不会出现异常的代码就不用处理。

抓抛模型：

* 过程一："抛"

程序执行时会在对应的异常代码中生成一个异常类的对象，并将对象抛出，一旦对象抛出后，后面的代码不会执行

* 过程二："抓"

抓住抛出的对象：①try-catch-finally ②throws

#### 5.3.1 try-catch-finally

> 引用狼来了故事，比如狼来了要吃羊，牧羊人自己能够搞定则try-catch，一般是编写者知道具体的异常

```java
try {
            testException1.testEx();//可能出现的异常
        } catch (Exception e) {//捕获的异常，类型要匹配
            e.printStackTrace();//打印异常堆栈信息  异常处理完，后面的代码才会执行
        }finally{//一定执行的代码
}
```

使用try-catch处理编译时异常时，在编译时不会报错，但在运行时依旧会报错。运行时异常即使try-catch之后依旧会爆红，还是会修改代码，编译时也看不出，所以对弈编译时异常一定要考虑异常处理。

+ finally（一定会被执行的）
  即使catch中出现异常或有return，try中有return，finally一定在return前执行一次；
  像数据库连接、输入输出流和socket需要手动的资源释放（释放是因为有cpu资源占用或泄漏风险），一般在finally中声明

#### 5.3.2 throws+异常类型

狼来了要吃羊，但此时狼比较狡猾，则把狼往山下抛给村里其他人解决。异常搞不定，把异常往上抛throws，因为是类继承，一直往上抛，如果还是处理不了，就会挂掉。

向上抛，交给上层处理，并没有解决掉，只有try-catch会处理掉

为什么要向上抛出，抛出就行吗

throw  和   throws

try catch finally

try catch finally  使用场景
全局异常处理  有哪些异常处理类

异常抛出后  程序还能执行吗

## 6 序列化与反序列化

为什么需要序列化

继承类  可以继承序列化


什么是default方法？https://zhuanlan.zhihu.com/p/33411641#:~:text=%E5%A6%82%E6%9E%9C%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E5%9C%A8%E5%A4%9A%E4%B8%AA%E6%8E%A5%E5%8F%A3%E4%B8%AD%E9%83%BD%E6%9C%89%E5%A3%B0%E6%98%8E%EF%BC%8C%E9%82%A3%E4%B9%88%EF%BC%8C%E4%BB%BB%E4%BD%95%E4%B8%80%E4%B8%AA,default%20%E5%AE%9E%E7%8E%B0%E9%83%BD%E4%B8%8D%E4%BC%9A%E8%A2%AB%E7%BB%A7%E6%89%BF%EF%BC%8C%E4%BD%A0%E5%B0%86%E4%BC%9A%E5%BE%97%E5%88%B0%E4%B8%80%E4%B8%AA%E7%BC%96%E8%AF%91%E6%97%B6%E9%94%99%E8%AF%AF%E3%80%82

public default 的权限访问  为什么不一致
接口的
public interface Base{
Result<Integer> save(Entity var1);
}

这个会被继承吗


类或接口如果不写public、private、default等访问权限  那么是默认什么权限?


匿名内部类https://blog.csdn.net/qq_34944851/article/details/51449420

内部类就是innerclass
https://www.cnblogs.com/wuhenzhidu/p/anonymous.html



那些是类或接口必须继承的方法
那些是类必须是实现的方法
接口也可以实现方法，然后类是否能够重新实现方法

